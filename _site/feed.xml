<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/feed.xml" rel="self" type="application/atom+xml" /><link href="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/" rel="alternate" type="text/html" /><updated>2021-05-18T02:41:00-05:00</updated><id>https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/feed.xml</id><title type="html">Kakao Enterprise AI Research</title><subtitle>카카오엔터프라이즈 연구 성과를 공개하는 리서치 플랫폼</subtitle><author><name>카카오엔터프라이즈</name></author><entry><title type="html">Deep Context- and Relation-Aware Learning for Aspect-based Sentiment Analysis</title><link href="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/acl-ijcnlp2021-dcran" rel="alternate" type="text/html" title="Deep Context- and Relation-Aware Learning for Aspect-based Sentiment Analysis" /><published>2021-08-01T00:00:00-05:00</published><updated>2021-08-01T00:00:00-05:00</updated><id>https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/acl-ijcnlp2021-dcran</id><content type="html" xml:base="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/acl-ijcnlp2021-dcran">&lt;h1 id=&quot;abstract&quot;&gt;Abstract&lt;/h1&gt;

&lt;p&gt;Existing works for aspect-based sentiment analysis (ABSA) have adopted a unified approach, which allows the interactive relations among subtasks. However, we observe that these methods tend to predict polarities based on the literal meaning of aspect and opinion terms and mainly consider relations implicitly among subtasks at the word level. In addition, identifying multiple aspect–opinion pairs with their polarities is much more challenging. Therefore, a comprehensive understanding of contextual information w.r.t. the aspect and opinion is further required in ABSA. In this paper, we propose Deep Contextualized Relation-Aware Network (DCRAN), which allows interactive relations among subtasks with deep contextual information based on two modules (i.e., Aspect and Opinion Propagation and Explicit Self-Supervised Strategies). Especially, we design novel self-supervised strategies for ABSA, which have strengths in dealing with multiple aspects. Experimental results show that DCRAN significantly outperforms previous state-of-the-art methods by large margins on three widely used benchmarks.&lt;/p&gt;</content><author><name>오신혁:카카오</name></author><category term="papers" /><summary type="html">Abstract</summary></entry><entry><title type="html">OutFlip: Generating Examples for Unknown Intent Detection with Natural Language Attack</title><link href="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/acl-ijcnlp2021-outflip" rel="alternate" type="text/html" title="OutFlip: Generating Examples for Unknown Intent Detection with Natural Language Attack" /><published>2021-08-01T00:00:00-05:00</published><updated>2021-08-01T00:00:00-05:00</updated><id>https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/acl-ijcnlp2021-outflip</id><content type="html" xml:base="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/acl-ijcnlp2021-outflip">&lt;h1 id=&quot;abstract&quot;&gt;Abstract&lt;/h1&gt;

&lt;p&gt;Out-of-domain (OOD) input detection is vital in a task-oriented dialogue system since the acceptance of unsupported inputs could lead to an incorrect response of the system. This paper proposes OutFlip, a method to generate out-of-domain samples using only in-domain training dataset automatically. A white-box natural language attack method HotFlip is revised to generate out-of-domain samples instead of adversarial examples. Our evaluation results showed that integrating OutFlip-generated out-of-domain samples into the training dataset could significantly improve an intent classification model’s out-of-domain detection performance.&lt;/p&gt;</content><author><name>heuristic:카카오엔터프라이즈</name></author><category term="papers" /><summary type="html">Abstract</summary></entry><entry><title type="html">ViLT: Vision-and-Language Transformer Without Convolution or Region Supervision</title><link href="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/icml2021-vilt" rel="alternate" type="text/html" title="ViLT: Vision-and-Language Transformer Without Convolution or Region Supervision" /><published>2021-07-18T00:00:00-05:00</published><updated>2021-07-18T00:00:00-05:00</updated><id>https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/icml2021-vilt</id><content type="html" xml:base="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/icml2021-vilt">&lt;h1 id=&quot;abstract&quot;&gt;Abstract&lt;/h1&gt;

&lt;p&gt;Vision-and-Language Pretraining (VLP) has improved performance on various joint vision-andlanguage downstream tasks. Current approaches to VLP heavily rely on image feature extraction processes, most of which involve region supervision (e.g., object detection) and the convolutional architecture (e.g., ResNet). Although disregarded in the literature, we find it problematic in terms of both (1) efficiency/speed, that simply extracting input features requires much more computation than the multimodal interaction steps; and (2) expressive power, as it is upper bounded to the expressive power of the visual encoder and its predefined visual vocabulary. In this paper, we present a minimal VLP model, Vision-andLanguage Transformer (ViLT), monolithic in the sense that processing of visual inputs is drastically simplified to just the same convolution-free manner that we process textual inputs. We show that ViLT is up to 60 times faster than previous VLP models, yet with competitive or better downstream task performance.&lt;/p&gt;</content><author><name>김원재:카카오</name></author><category term="papers" /><summary type="html">Abstract</summary></entry><entry><title type="html">Conditional Variational Autoencoder with Adversarial Learning for End-to-End Text-to-Speech</title><link href="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/icml2021-e2e-tts" rel="alternate" type="text/html" title="Conditional Variational Autoencoder with Adversarial Learning for End-to-End Text-to-Speech" /><published>2021-07-18T00:00:00-05:00</published><updated>2021-07-18T00:00:00-05:00</updated><id>https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/icml2021-e2e-tts</id><content type="html" xml:base="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/icml2021-e2e-tts">&lt;h1 id=&quot;abstract&quot;&gt;Abstract&lt;/h1&gt;

&lt;p&gt;Several recent end-to-end text-to-speech (TTS) models enabling single-stage training and parallel sampling have been proposed, but their sample quality does not match that of two-stage TTS systems. In this work, we present a parallel end-to-end TTS method that generates more natural sounding audio than current two-stage models. Our method adopts variational inference augmented with normalizing flows and an adversarial training process, which improves the expressive power of generative modeling. We also propose a stochastic duration predictor to synthesize speech with diverse rhythms from input text. With the uncertainty modeling over latent variables and the stochastic duration predictor, our method expresses the natural one-to-many relationship in which a text input can be spoken in multiple ways with different pitches and rhythms. A subjective human evaluation (mean opinion score, or MOS) on the LJ Speech, a single speaker dataset, shows that our method outperforms the best publicly available TTS systems and achieves a MOS comparable to ground truth.&lt;/p&gt;</content><author><name>jay:카카오엔터프라이즈</name></author><category term="papers" /><summary type="html">Abstract</summary></entry><entry><title type="html">U-Convolution Based Residual Echo Suppression With Multiple Encoders</title><link href="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/icassp2021-u-convolution-based-residual-eco-suppression" rel="alternate" type="text/html" title="U-Convolution Based Residual Echo Suppression With Multiple Encoders" /><published>2021-06-13T00:00:00-05:00</published><updated>2021-06-13T00:00:00-05:00</updated><id>https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/icassp2021-u-convolution-based-residual-eco-suppression</id><content type="html" xml:base="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/icassp2021-u-convolution-based-residual-eco-suppression">&lt;h1 id=&quot;abstract&quot;&gt;Abstract&lt;/h1&gt;

&lt;p&gt;In this paper, we propose an efficient end-to-end neural network that can estimate near-end speech using a U- convolution block by exploiting various signals to achieve residual echo suppression (RES). Specifically, the proposed model employs multiple encoders and an integration block to utilize complete signal information in an acoustic echo can- cellation system and also applies the U-convolution blocks to separate near-end speech efficiently. The proposed network affords an improvement in the perceptual evaluation of speech quality (PESQ) and the short-time objective intelligi- bility (STOI), as compared to baselines, in scenarios involving smart audio devices. The experimental results show that the proposed method outperforms the baselines for various types of mismatched background noise and environmental reverberation, while requiring low computational resources.&lt;/p&gt;</content><author><name>chris:카카오엔터프라이즈</name></author><category term="papers" /><summary type="html">Abstract</summary></entry><entry><title type="html">Multitask Learning and Joint Optimization For Transformer-Rnn-Tranducer Speech Recognition</title><link href="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/icassp2021-transformer-rnn-tranducer-speech-recognition" rel="alternate" type="text/html" title="Multitask Learning and Joint Optimization For Transformer-Rnn-Tranducer Speech Recognition" /><published>2021-06-13T00:00:00-05:00</published><updated>2021-06-13T00:00:00-05:00</updated><id>https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/icassp2021-transformer-rnn-tranducer-speech-recognition</id><content type="html" xml:base="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/icassp2021-transformer-rnn-tranducer-speech-recognition">&lt;h1 id=&quot;abstract&quot;&gt;Abstract&lt;/h1&gt;

&lt;p&gt;Recently, several types of end-to-end speech recognition methods named transformer-transducer were introduced. According to those kinds of methods, transcription networks are generally modeled by transformer-based neural networks, while prediction networks could be modeled by either transformers or recurrent neural networks (RNN). This paper explores multitask learning, joint optimization, and joint decoding methods for transformer-RNN-transducer systems. Our proposed methods have the main advantage in that the model can maintain information on the large text corpus. We prove their effectiveness by performing experiments utilizing the well-known ESPNET toolkit for the widely used Librispeech datasets. We also show that the proposed meth- ods can reduce word error rate (WER) by 16.6 % and 13.3 % for test-clean and test-other datasets, respectively, with- out changing the overall model structure nor exploiting an external LM.&lt;/p&gt;</content><author><name>jeffrey:카카오엔터프라이즈</name></author><category term="papers" /><summary type="html">Abstract</summary></entry><entry><title type="html"></title><link href="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/deepdive/210521" rel="alternate" type="text/html" title="" /><published>2021-05-21T00:00:00-05:00</published><updated>2021-05-21T00:00:00-05:00</updated><id>https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/deepdive/210521</id><content type="html" xml:base="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/deepdive/210521"></content><author><name>samantha:작성,편집</name></author><category term="deepdive" /><category term="Text Style Transfer" /><summary type="html"></summary></entry><entry><title type="html">Suppressing Spoof-irrelevant Factors for Domain-agnostic Face Anti-spoofing</title><link href="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/ieeeaccess-face-anti-spoofing" rel="alternate" type="text/html" title="Suppressing Spoof-irrelevant Factors for Domain-agnostic Face Anti-spoofing" /><published>2021-04-30T00:00:00-05:00</published><updated>2021-04-30T00:00:00-05:00</updated><id>https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/ieeeaccess-face-anti-spoofing</id><content type="html" xml:base="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/ieeeaccess-face-anti-spoofing">&lt;h1 id=&quot;abstract&quot;&gt;Abstract&lt;/h1&gt;

&lt;p&gt;Face anti-spoofing aims to prevent false authentications of face recognition systems by distinguishing whether an image is originated from a human face or a spoof medium. In this work, we note that images from unseen domains having different spoof-irrelevant factors (e.g., background patterns and subject) induce domain shift between source and target distributions. Also, when the same SiFs are shared by the spoof and genuine images, they show a higher level of visual similarity and this hinders accurate face anti-spoofing. Hence, we aim to minimize the discrepancies among different domains via alleviating the effects of SiFs, and achieve improvements in generalization to unseen domains. To realize our goal, we propose a novel method called a Doubly Adversarial Suppression Network (DASN) that is trained to neglect the irrelevant factors and to focus more on faithful task-relevant factors. Our DASN consists of two types of adversarial learning schemes. In the first adversarial learning scheme, multiple SiFs are suppressed by deploying multiple discrimination heads that are trained against an encoder. In the second adversarial learning scheme, each of the discrimination heads is also adversarially trained to suppress a spoof factor, and the group of the secondary spoof classifier and the encoder aims to intensify the spoof factor by overcoming the suppression. We evaluate the proposed method on four public benchmark datasets, and achieve remarkable evaluation results in generalizing to unseen domains. The results demonstrate the effectiveness of the proposed method.&lt;/p&gt;</content><author><name>김태욱:카카오엔터프라이즈</name></author><category term="papers" /><category term="face anti-spoofing" /><summary type="html">Abstract</summary></entry><entry><title type="html">RYANSQL: Recursively Applying Sketch-based Slot Fillings for Complex Text-to-SQL in Cross-Domain Databases</title><link href="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/cljournal2021-ryansql" rel="alternate" type="text/html" title="RYANSQL: Recursively Applying Sketch-based Slot Fillings for Complex Text-to-SQL in Cross-Domain Databases" /><published>2021-03-26T00:00:00-05:00</published><updated>2021-03-26T00:00:00-05:00</updated><id>https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/cljournal2021-ryansql</id><content type="html" xml:base="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/cljournal2021-ryansql">&lt;p&gt;스파이더 챌린지&lt;sup&gt;SPIDER Text-to-SQL Challenge&lt;/sup&gt; 성과를 정리한 공동 연구 논문이 Computational Linguistics에 실렸습니다. 미국 예일대학교에서 주최한 스파이더 챌린지는 각종 데이터를 정리∙보관할 때 사용하는 데이터베이스와 자연어 형태의 사용자 질의가 주어졌을때, 이 질의문을 SQL&lt;sup&gt;Structured Query Language&lt;/sup&gt;&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;문으로 변환해주는 Text-to-SQL&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; 알고리즘의 정확도를 평가합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ailab-papers/assets/img/2021-03-26-cljournal-ryansql/001.png&quot; width=&quot;&quot; align=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em class=&quot;center&quot;&gt;[ 표 1 ] 주어진 자연어 문장과 데이터베이스를 이용해 SQL 문을 생성하는 예시&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;자연어 질의문을 SQL 문으로 변환하는 데에는 스케치 기반 슬롯 채우기&lt;sup&gt;sketch-based Slot Filling&lt;/sup&gt;가 주로 활용돼 왔습니다. SELECT&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; 문에 몇 개의 열&lt;sup&gt;column&lt;/sup&gt;을 입력해야 하는지, 어떤 열을 선택해야 하는지, 집계 함수&lt;sup&gt;aggregator&lt;/sup&gt;&lt;sup id=&quot;fnref:4&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;로 무엇을 써야 하는지 등 판별해야 할 정보&lt;sup&gt;slot&lt;/sup&gt;를 먼저 구분하고 나서, 각 정보의 값을 채워넣는 식입니다. 다만 이 방식으로는 쿼리 속에 또 다른 쿼리가 든 중첩 질의&lt;sup&gt;nested query&lt;/sup&gt;를 생성하는 데 한계가 있습니다. SELECT 문의 개수가 정해지지 않아서 전체 설계도 자체를 그릴 수 없기 때문입니다.&lt;/p&gt;

&lt;p&gt;공동 연구팀이 제안한 Text-to-SQL 알고리즘인 RYQNSQL&lt;sup&gt;Recursively Yielding Annotation Network for SQL&lt;/sup&gt;은 대규모 영어 비라벨링 말뭉치를 사전학습한 언어 모델인 BERT에 자체 고안한 SPC&lt;sup&gt;Statement Position Code&lt;/sup&gt; 기법을 적용했습니다. SPC는 슬롯을 채울 때 중첩된 SELECT문을 좀 더 정확하게 생성할 수 있도록 합니다. 실험 결과, 스파이더 벤치마크 데이터셋에 대해 현재 최고 성능의(SOTA)&lt;sup id=&quot;fnref:5&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt; 모델보다 3.2%p 더 높은 58.2%의 정확도를 달성했습니다.&lt;/p&gt;

&lt;p&gt;카카오엔터프라이즈는 데이터의 스키마(테이블 이름, 열 이름)뿐만 아니라 실제 값도 활용하는 방식 등으로 자사 Text-to-SQL 알고리즘의 성능과 사용성을 높여 기업 데이터베이스 활용의 문턱을 낮추는 데 기여할 계획입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;overall-architecture&quot;&gt;Overall Architecture&lt;/h1&gt;

&lt;p&gt;Figure 1 shows the overall network architecture of the input encoder. The input encoder consists of five layers: Embedding layer, Embedding Encoder layer, Question-Column Alignment layer, Table Encoder layer, and Question-Table Alignment layer. Table 1 shows the proposed sketch for a SELECT statement. The sketch-based slot-filling decoder predicts values for slots of the proposed sketch, as well as the number of slots.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ailab-papers/assets/img/2021-03-26-cljournal-ryansql/002.png&quot; width=&quot;&quot; align=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em class=&quot;center&quot;&gt;[ Figure 1 ] Network architecture of the proposed input encoder. S represents self-attention.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ailab-papers/assets/img/2021-03-26-cljournal-ryansql/003.png&quot; width=&quot;80%&quot; align=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[ table 1 ] Proposed sketch for a SELECT statement. $TBL and $COL represent a table and a column, respectively. $AGG is one of {none, max, min, count, sum, avg}, $ARI is one of the arithmetic operators {none, -, +, *, / }, and $COND is one of the conditional operators {between, =, &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=, !=, in, like, is, exists}. $DIST and $NOT are boolean variables representing the existence of keywords DISTINCT and NOT, respectively. $ORD is a binary value for keywords ASC/DESC, and $CONJ is one of conjunctions {AND, OR}. $VAL is the value for WHERE/HAVING condition; $SEL represents the slot for another SELECT statement.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;experiments&quot;&gt;Experiments&lt;/h1&gt;

&lt;p&gt;Table 2 shows that the proposed system RYANSQL improves the previous sketch-based slot filling system RCSQL by a large margin of 15% on the dev set. Note that the RCSQL fine-tuned another well known pretrained language model ELMo. With the use of BERT, among the systems without database content, the proposed systems (RYANSQL + BERT and RYANSQL v2 + BERT) outperforms the previous state-of-the-art by 2.5% and 4.9% respectively on the hidden test dataset. The proposed system still shows competitive results compared to the systems using database content; RATSQL v3 + BERT outperforms the proposed system by better aligning user questions and database schemas using database content.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ailab-papers/assets/img/2021-03-26-cljournal-ryansql/005.png&quot; width=&quot;90%&quot; align=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em class=&quot;center&quot;&gt;[ Table 2 ] Evaluation results of the proposed systems and other state-of-the-art systems.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We evaluated the proposed models on the CSpider dataset. CSpider is a chinese-translated version of the Spider benchmark. Only the question of the spider dataset is translated; database table names and column names remain as English. Evaluation on the CSpider dataset will show if the proposed model could be applied on the different languages, even when the question language and database schema language are different. To handle the case, we used multilingual BERT, which has the same network architecture with BERT-base but is trained using multilingual corpus.&lt;/p&gt;

&lt;p&gt;The results are shown in Table 3. Compared to the exact matching accuracy 51.4% of RYANSQL + BERT-base on Spider dataset, the multilingual version shows 10% lower accuracy on dev set, but still shows comparable results to other state-of-the-art systems which are designed for CSpider dataset. Our proposed system showed 34.7% test accuracy on the test set, and ranked at 2nd place on the leaderboard.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ailab-papers/assets/img/2021-03-26-cljournal-ryansql/005.png&quot; width=&quot;90%&quot; align=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em class=&quot;center&quot;&gt;[ Table 3 ] Evaluation results on CSpider dataset with other state-of-the-art systems.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;footnotes&quot;&gt;Footnotes&lt;/h3&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;관계형 데이터베이스 관리를 위해 설계된 특수목적의 프로그래밍 언어 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;NLI2DB&lt;sup&gt;natural language interface to databases&lt;/sup&gt;라고도 부른다. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;테이블 전체 또는 일부 열과 행 값을 호출하는 명령어 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;값 집합에 대한 산술적인 계산(레코드의 수, 값의 합, 값의 평균, 최대값, 최소값)의 결과값을 출력한다. &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;논문 제출 시점(2020년 4월) 최고 성능 &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>heuristic:카카오엔터프라이즈</name></author><category term="papers" /><category term="NLI2DB" /><category term="Text-to-SQL" /><summary type="html">스파이더 챌린지SPIDER Text-to-SQL Challenge 성과를 정리한 공동 연구 논문이 Computational Linguistics에 실렸습니다. 미국 예일대학교에서 주최한 스파이더 챌린지는 각종 데이터를 정리∙보관할 때 사용하는 데이터베이스와 자연어 형태의 사용자 질의가 주어졌을때, 이 질의문을 SQLStructured Query Language1문으로 변환해주는 Text-to-SQL2 알고리즘의 정확도를 평가합니다. 관계형 데이터베이스 관리를 위해 설계된 특수목적의 프로그래밍 언어 &amp;#8617; NLI2DBnatural language interface to databases라고도 부른다. &amp;#8617;</summary></entry><entry><title type="html">A Plug-in Method for Representation Factorization in Connectionist Models</title><link href="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/ieee2020-fden" rel="alternate" type="text/html" title="A Plug-in Method for Representation Factorization in Connectionist Models" /><published>2021-02-10T00:00:00-06:00</published><updated>2021-02-10T00:00:00-06:00</updated><id>https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/ieee2020-fden</id><content type="html" xml:base="https://pages.github.kakaocorp.com/ailab-papers/ailab-papers/papers/ieee2020-fden">&lt;p&gt;일반적으로 딥러닝 모델의 성능은 과제를 수행하는 데 필요한 필수 정보를 추출하고 이를 최대한 압축한 임베딩 벡터&lt;sup&gt;embedding vector&lt;/sup&gt;를 제대로 표현하는 능력에 있다고 해도 과언이 아닙니다. 다만 각 차원이 여러 요인을 함축적으로 포함하는 그 특성상, 사람이 벡터를 해석하는 데에는 한계가 있습니다. 머리 색, 머리 길이, 얼굴형, 눈썹 모양, 얼굴색 등이 얼굴을 구성하는 요소라고 본다면, 딥러닝 모델이 생성한 벡터는 차원1-머리색/머리길이, 차원2-머리길이/얼굴색 등으로 여러 차원에 여러 요인이 복잡하게 얽혀 있죠.&lt;/p&gt;

&lt;p&gt;이에 데이터를 독립 요인&lt;sup&gt;independent factor&lt;/sup&gt;에 상응하는 해석 가능한 표현&lt;sup&gt;disentangled representation&lt;/sup&gt;으로 만드는 방법에 관한 연구가 활발하게 이뤄지고 있습니다. 공동 연구팀 또한 이 대열에 합류, 총 상관계수&lt;sup&gt;total correlation&lt;/sup&gt;&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;를 최소화하는 방식으로 의미상 제어할 수 있는 요인으로 임베딩 벡터를 분해하는 기법인 FDEN&lt;sup&gt;Factors Decomposer-Entangler Network&lt;/sup&gt;을 제안했습니다.&lt;/p&gt;

&lt;p&gt;FDEN은 학습된 모델&lt;sup&gt;pre-trained model&lt;/sup&gt;의 가중치&lt;sup&gt;weight&lt;/sup&gt; 값을 변경하지 않고도 사용할 수 있는 플러그인&lt;sup&gt;plug-in&lt;/sup&gt; 방식으로 동작합니다. 모델이 추출한 임베딩 벡터에서 요인에 영향을 미치는 부분을 찾아내는(해석하는) 별도의 단계를 뒀다는 의미입니다. 이 덕분에 우수한 성능을 내는 여러 학습 모델에 바로 적용해볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ailab-papers/assets/img/2021-02-10-IEEE-FDEN/001.png&quot; width=&quot;70%&quot; align=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[ 그림 1 ] 가중치를 고정한 사전학습한 모델에 플러그인 방식으로 동작하는 FDEN은 출력된 임베딩 벡터 z를 해석가능한 표현 \(\tilde{z}\)로 바꾼다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;연구팀은 스타일 변환&lt;sup&gt;style transfer&lt;/sup&gt;, 이미지 간 번역&lt;sup&gt;image-to-image translation&lt;/sup&gt;, 퓨샷 러닝&lt;sup&gt;few-shot learning&lt;/sup&gt; 등 다양한 태스크에서 우수한 성능을 내는 모델에 FDEN을 적용했습니다. 그 결과, FDEN은 사람이 라벨링한 요인을 효과적으로 분해할 수 있었습니다. 독립 요인(\(f_0\)+\(f_1\)+\(f_2\)…+\(f_n\))을 합쳐 기존 데이터(\(z\))와 유사한 데이터(\(\tilde{z}\))도 생성할 수 있음을 확인했습니다. 이는 사람이 해석 가능한 독립 요인을 조절해 새로운 데이터 혹은 사람이 원하는 데이터를 만들어낼 수 있음을 시사합니다.&lt;/p&gt;

&lt;p&gt;연구팀은 비지도학습&lt;sup&gt;unsupervised learning&lt;/sup&gt;&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;을 이용해 사람이 찾지 못한 요인을 섬세하게 분해할 방법론에 관한 연구를 진행할 계획입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;overall-architecture&quot;&gt;Overall Architecture&lt;/h1&gt;

&lt;p&gt;The objective of FDEN is to decompose input representation \(z\) into independent and semantically interpretable factors without losing the original information in the latent or feature representation \(z\). To achieve this aim, we compose an FDEN with three modules (Figure. 1): Decomposer \(D\), Factorizer \(F\), and Entangler \(E\). Note that because FDEN uses a fixed pretrained network and deals with the latent or feature representation from the network, it allows factorizing the input representation for other new tasks while maintaining the network capacity or power for its original tasks intact.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ailab-papers/assets/img/2021-02-10-IEEE-FDEN/002.png&quot; width=&quot;&quot; align=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[ Figure 1 ] FDEN is divided into three modules: Decomposer \(D\), Factorizer \(F\), and Entangler \(E\). The model is an autoencoder-like architecture that takes representation \(z\) as the input and reconstructs its original representation (\(\tilde{z}\)). (a) First, Decomposer \(D\) takes a representation \(z\) from a fixed pretrained network as the input and decomposes it into a set of factors \(f_i\) (\(∀_i\) ∈ \(N\)). (b) Next, Factorizer \(F\) uses an information theoretic way to maximize the independence of each factor. (c) Finally, Entangler \(E\) takes the factors and reconstructs their original representation (\(\tilde{z}\)).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;experiments&quot;&gt;Experiments&lt;/h1&gt;

&lt;p&gt;Our objective here is to demonstrate that each module of FDEN is effective at decomposing a latent representation into independent factors. First, we evaluate the effectiveness of factors by performing various downstream tasks. Next, we analyze individual units of factors to verify if a representation is indeed reasonably factorized.  We perform style transfer with human labeled attributes (Fig. 2). The results of style transfer with FDEN confirms a clear transfer of attributes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ailab-papers/assets/img/2021-02-10-IEEE-FDEN/003.png&quot; width=&quot;&quot; align=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[ Figure 2 ] Results of style transfer for the CelebA-128 dataset with N=7 factors (where \(f_0\) is the style factor). Images in the first and second columns are reconstructed images from Pioneer Network and FDEN, respectively. The following images are reconstructed images with one attribute opposite to the input image (e.g., \(1{^{st}}\) row \(f_3\): “not bald” transferred to “bald”; \(2{^{nd}}\) row \(f_3\): “young” transferred to “not young”). The original attributes of both input images are: “not bald”, “male”, “young”, “without smile”, “without beard”, “without eyeglasses” (note that the 1st row image is annotated as “with goatee, but without beard”).&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;주어진 요인의 독립성&lt;sup&gt;independence&lt;/sup&gt;를 직접 계산할 수 있는 수치 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;사람이 라벨링하지 않은 데이터를 이용한 학습 방법 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>윤재석:고려대학교</name></author><category term="papers" /><category term="disentangled representation" /><category term="factorial representation" /><summary type="html">일반적으로 딥러닝 모델의 성능은 과제를 수행하는 데 필요한 필수 정보를 추출하고 이를 최대한 압축한 임베딩 벡터embedding vector를 제대로 표현하는 능력에 있다고 해도 과언이 아닙니다. 다만 각 차원이 여러 요인을 함축적으로 포함하는 그 특성상, 사람이 벡터를 해석하는 데에는 한계가 있습니다. 머리 색, 머리 길이, 얼굴형, 눈썹 모양, 얼굴색 등이 얼굴을 구성하는 요소라고 본다면, 딥러닝 모델이 생성한 벡터는 차원1-머리색/머리길이, 차원2-머리길이/얼굴색 등으로 여러 차원에 여러 요인이 복잡하게 얽혀 있죠.</summary></entry></feed>